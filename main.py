import tkinter as tk
from PIL import Image, ImageTk
from tkinter.filedialog import askopenfile
import os 
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.PublicKey import RSA
from Crypto.Util.Padding import pad
from Crypto.Protocol.KDF import PBKDF2
from Crypto.Cipher import PKCS1_OAEP
import hashlib
from client import Client
from server import Server
import asyncio
import threading
import time
import sys
import random

def open_file():
    global client
    file = tk.filedialog.askopenfile(mode='r')
    if file:
        filepath = os.path.abspath(file.name)
        client.send_file(filepath)
        file_btn.set("Browse")
    text_transfer_file.set("send file")

def send_message():
    print(text_input.get(1.0, "end-1c"))
    pass 
def password_handle(keys_path):
    popup = tk.Tk()
    info = tk.Label(popup, text="Input password:", font="Raleway")
    info.grid(columnspan=3, column=1, row=0)
    text_input = tk.Text(popup,height = 1,width = 20)
    text_input.grid(columnspan=3,column=1, row=1)
    pass_btn = tk.Button(popup, text='check',  command=lambda: check_password(keys_path,text_input.get("1.0", "end-1c"),popup), font="Raleway", bg="#20bebe", fg="white", height=2, width=15)
    pass_btn.grid(columnspan=3,column=1, row=2)

def check_password(keys_path,given_pass,window):
    with open(keys_path+ '/local/local_key.bin', 'rb') as f:
        hashed_key = f.read()
    # Verify the hashed key by computing the SHA-256 hash of the original key
    salt = b'solniczka'
    key_length = 16
    given_password_aes = PBKDF2(given_pass,salt,dkLen=key_length)
    hashed_given_password_aes = hashlib.sha256(given_password_aes).digest()
    if hashed_given_password_aes == hashed_key:
        print("Hashed key is valid")
        window.destroy()
    else:
        print("Hashed key is invalid")
        sys.exit()
def check_if_keys_exist():
    popup = tk.Toplevel()
    info = tk.Label(popup, text="Select directory that contains public and private key", font="Raleway")
    info.grid(columnspan=3, column=0, row=0)

    popup.attributes('-topmost',True)
    popup.grab_set()
    folder_selected = tk.filedialog.askdirectory()
    popup.destroy()
    if not os.path.exists(folder_selected+"public_key.pem") or not os.path.exists(folder_selected+"private_key.pem"):

        generate_keys_new(folder_selected)
    popup.destroy()
    return folder_selected
    
def generate_keys_new(folder_selected):
    passcode = "kutasek"
    key = RSA.generate(2048)
    #generate private
    private_key = key.export_key()
    #generate public
    public_key = key.publickey().export_key()
    #aes key
    salt = b'solniczka'
    key_len = 16
    #from human password to AES-128 
    local_key = PBKDF2(passcode,salt,dkLen=key_len)
    #print(local_key)
    #sha256 hash of AES-128
    hashed_local_key = hashlib.sha256(local_key).digest()
    #print(hashed_local_key)
    # Initialize the AES cipher in CBC mode
    cipher = AES.new(local_key, AES.MODE_CBC)
    padded_private_key = pad(private_key, AES.block_size)

    # Encrypt the private key using the AES cipher in CBC mode
    # The IV (initialization vector) is generated by the cipher object
    encrypted_private_key = cipher.encrypt(padded_private_key)
    #create dirs for keys
    if not os.path.exists(folder_selected + '/private/'):
        os.mkdir(folder_selected + '/private/')
    if not os.path.exists(folder_selected + '/public/'):
        os.mkdir(folder_selected + '/public/')
    if not os.path.exists(folder_selected + '/local/'):
        os.mkdir(folder_selected + '/local/')
    #write keys
    print("hashedlocal: "+ str(hashed_local_key))
    with open(folder_selected +'/local/local_key.bin', 'wb') as f:
        f.write(hashed_local_key)
    with open(folder_selected +'/public/public_key.pem', 'wb') as f:
        f.write(public_key)
    with open(folder_selected +'/private/private_key.pem', 'wb') as f:
        f.write(encrypted_private_key)
    return folder_selected
def generate_session_key(other_person_public_key):
    session_key = get_random_bytes(32)
    # Encrypt the session key using the public key
    cipher_rsa = PKCS1_OAEP.new(other_person_public_key)
    encrypted_session_key = cipher_rsa.encrypt(session_key)
    return encrypted_session_key 

def create_server():
    global server, public_key, recv_text, mylabel
    recv_text = ''
    while True:
        text = server.receive_text_from_client()

        if text == "send_text":
            txt = server.receive_text_from_client()
            print(txt)
            recv_text += f'{txt}\n'
            mylabel.config(text=recv_text) # update te messagebox
            #print(recv_text)
        
        elif text == "send_file":
            server.receive_file_from_client()

        elif text == "":
            return # text == '' when connection is lost
        
def check_address(text, window=None):
    global addr, port
    try:
        text.index(':')
    except ValueError:
        return
    else:
        text = text.split(':')
        print(text)
        if window is not None:
            window.destroy()
        addr, port = text[0], int(text[1])
        
        

def generate_session_key(public_key):
    return "public_session_key"

def server_accept():
    global server, mylabel
    mylabel.config(text='accepting')
    server.server.listen()
    server.client, server.addr = server.server.accept()
    return

async def create_client():
    global client, connected, server, key_folder, session_key, mylabel, addr, port

    client = Client(addr, port)
    mylabel.config(text='create client')
    server = Server('localhost', 9999)
    thread1 = threading.Thread(target=server_accept, args=())
    thread1.start()
    #mylabel.config(text='dalej')
    while True:
        try:
            #mylabel.config(text=f'try catch {addr}:{port}')
            client.client.connect((addr, port))
        except ConnectionRefusedError:
            continue
        else:
            
            mylabel.config(text='else statement!')
            thread1.join()
            mylabel.config(text='after join')
            #time.sleep(5)
            #when connected successfully change status to connected
            #do it here
            #-------------------#
            task = asyncio.create_task(server.receive_key())
            
            key = "public key 1"
            # with open(key_folder, 'r') as f:      $uncomment and pass the file with
            #     key = f.read()
            client.send_key(key)
            mylabel.config(text='siema')
            public_key = await task 
            print(public_key)
            mylabel.config(text=public_key)

            task = asyncio.create_task(server.receive_key())
            session_key = generate_session_key(public_key)
            client.send_key(session_key)

            sk = await task
            mylabel.config(text=f'')
            print(sk)
            if not sk == '':
                session_key = sk

            connected = True
            connection.config(text=f'Status: {connected}')
            #client.send_key() #send encrypted public key
            #meanwhile server retrieves public key
            return
 
    

def connect():
    popup = tk.Tk()
    info = tk.Label(popup, text="Give another user address:", font="Raleway")
    info.grid(columnspan=3, column=1, row=0)
    text_input = tk.Text(popup,height = 1,width = 20)
    text_input.grid(columnspan=3,column=1, row=1)
    file_btn = tk.Button(popup, text='connect', command=lambda: check_address(text_input.get("1.0", "end-1c"), window=popup), font="Raleway", bg="#20bebe", fg="white", height=2, width=15)
    file_btn.grid(columnspan=3,column=1, row=2)
    popup.attributes('-topmost',True)
    popup.grab_set()
    popup.mainloop()

def client_handler():
    global addr, port, connected, mylabel
    connect()
    while True:
        asyncio.run(create_client())
        #mylabel.config(text='eluwina')
        t1 = threading.Thread(target=create_server, args=(), daemon=True)
        t1.start()
        t1.join()
    #mylabel.config(text='before client_handler while')
    
        #mylabel.config(text='client_handler while')
        # if not connected:
        #     if t1.is_alive():
        #         t1.join()
        #     asyncio.run(create_client())
        #     t1 = threading.Thread(target=create_server, args=(), daemon=True)
        #     t1.start()
            


def main():
    global mylabel, client, server, connected, session_key, key_folder, connection
    connected = False


    root = tk.Tk()
    canvas = tk.Canvas(root, width=500, height=300)
    root.withdraw()
    key_folder = check_if_keys_exist()
    password_handle(key_folder)
    root.deiconify()
    print("ssss")
    root.iconify()
    canvas.grid(columnspan=10, rowspan=10)
    #logo
    logo = Image.open('logo.png')
    logo = ImageTk.PhotoImage(logo)
    logo_label = tk.Label(image=logo)
    logo_label.image = logo
    logo_label.grid(column=1, row=0)
    #file transfer text
    instructions = tk.Label(root, text="Select file to transfer", font="Raleway")
    instructions.grid(columnspan=3, column=0, row=1)
    #message fransfer text
    instructions2 = tk.Label(root, text="write your message", font="Raleway")
    instructions2.grid(columnspan=3, column=0, row=3)
    text_input = tk.Text(root,height = 5,
                    width = 20)
    text_input.grid(columnspan=3,column=0, row=4)
    #file transfer button 
    file_btn = tk.Button(root, text='send file', command=lambda:open_file(), font="Raleway", bg="#20bebe", fg="white", height=2, width=15)
    file_btn.grid(column=1, row=2)
    #message tranfer button
    message_btn = tk.Button(root, text='send message', command=lambda:client.send_text(text_input.get("1.0", "end-1c")), font="Raleway", bg="#20bebe", fg="white", height=2, width=15)
    message_btn.grid(column=1,row=5)
    #field to show received text
    mylabel = tk.Label(root, text=f"messages:", font="Raleway")
    mylabel.grid(columnspan=3, column=0, row=6)

    #connection status
    connection = tk.Label(root, text=f"Connected: {connected}", font="Raleway")
    connection.grid(columnspan=3, column=0, row=10)

    canvas = tk.Canvas(root, width=600, height=250)
    canvas.grid(columnspan=3)

    # t1 = threading.Thread(target=create_server, args=(), daemon=True) #watki sa usuwane przy zakonczeniu programu
    # t1.start()
    t2 = threading.Thread(target=lambda:client_handler(), args=(), daemon=True)
    t2.start()
    
    root.mainloop()


if __name__ == '__main__':
    main()
    