import tkinter as tk
from PIL import Image, ImageTk
from tkinter.filedialog import askopenfile
import os 
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.PublicKey import RSA
from Crypto.Util.Padding import pad, unpad
from Crypto.Protocol.KDF import PBKDF2
from Crypto.Cipher import PKCS1_OAEP
import hashlib
from client import Client
from server import Server
import asyncio
import threading
import sys


def open_file():
    global client
    file = tk.filedialog.askopenfile(mode='r')
    if file:
        filepath = os.path.abspath(file.name)
        client.send_file(filepath)

def password_handle(keys_path):
    popup = tk.Tk()
    info = tk.Label(popup, text="Input password:", font="Raleway")
    info.grid(columnspan=3, column=1, row=0)
    text_input = tk.Text(popup,height = 1,width = 20)
    text_input.grid(columnspan=3,column=1, row=1)
    pass_btn = tk.Button(popup, text='check',  command=lambda: check_password(keys_path,text_input.get("1.0", "end-1c"), window=popup), font="Raleway", bg="#20bebe", fg="white", height=2, width=15)
    pass_btn.grid(columnspan=3,column=1, row=2)


def check_password(keys_path,given_pass,window):
    global valid

    with open(keys_path+ '/local/local_key.bin', 'rb') as f:
        hashed_key = f.read()
    # Verify the hashed key by computing the SHA-256 hash of the original key
    salt = b'solniczka'
    key_length = 16
    
    given_password_aes = PBKDF2(given_pass,salt,dkLen=key_length)
    hashed_given_password_aes = hashlib.sha256(given_password_aes).digest()
    if hashed_given_password_aes == hashed_key:
        print("Hashed key is valid")
        valid = True
        t2 = threading.Thread(target=lambda:client_handler(), args=(), daemon=True)
        t2.start()
        window.destroy()
    else:
        print("Hashed key is invalid")
        sys.exit()

def check_if_keys_exist():
    popup = tk.Toplevel()
    info = tk.Label(popup, text="Select directory that contains public and private key", font="Raleway")
    info.grid(columnspan=3, column=0, row=0)

    popup.attributes('-topmost',True)
    popup.grab_set()
    folder_selected = tk.filedialog.askdirectory()
    popup.destroy()
    if not os.path.exists(folder_selected+"public_key.pem") or not os.path.exists(folder_selected+"private_key.pem"):
        generate_keys_new(folder_selected)

    popup.destroy()
    return folder_selected
    
def generate_keys_new(folder_selected):
    passcode = "admin123"

    key = RSA.generate(2048)
    #generate private
    
    private_key = key.export_key()
    #generate public
    public_key = key.publickey().export_key()
    #aes key
    salt = b'solniczka'
    key_len = 16
    #from human password to AES-128 
    local_key = PBKDF2(passcode,salt,dkLen=key_len)
    #sha256 hash of AES-128
    hashed_local_key = hashlib.sha256(local_key).digest()
    # Initialize the AES cipher in CBC mode
    cipher = AES.new(hashed_local_key, AES.MODE_CBC)
    initialization_vector = cipher.iv
    
    padded_private_key = pad(private_key, AES.block_size)

    # Encrypt the private key using the AES cipher in CBC mode
    # The IV (initialization vector) is generated by the cipher object
    
    encrypted_private_key = cipher.encrypt(padded_private_key)
    #create dirs for keys
    if not os.path.exists(folder_selected + '/private/'):
        os.mkdir(folder_selected + '/private/')
    if not os.path.exists(folder_selected + '/public/'):
        os.mkdir(folder_selected + '/public/')
    if not os.path.exists(folder_selected + '/local/'):
        os.mkdir(folder_selected + '/local/')
    #write keys
    print("hashedlocal: "+ str(hashed_local_key))
    with open(folder_selected +'/local/local_key.bin', 'wb') as f:
        f.write(hashed_local_key)
    with open(folder_selected +'/local/iv.bin', 'wb') as f:
        f.write(initialization_vector)
    with open(folder_selected +'/public/public_key.pem', 'wb') as f:
        f.write(public_key)
    with open(folder_selected +'/private/private_key.pem', 'wb') as f:
        f.write(encrypted_private_key)
    return folder_selected

def decypher_session_key(session_key):

    with open(key_folder +'/private/private_key.pem', 'rb') as f:
        encrypted = f.read()
    
    with open(key_folder +'/local/iv.bin', 'rb') as f:
        iv = f.read()
    
    with open(key_folder +'/local/local_key.bin', 'rb') as f:
        local_key = f.read()

    cipher = AES.new(local_key, AES.MODE_CBC, iv=iv)
    pk = cipher.decrypt(encrypted)

    pk = unpad(pk, AES.block_size)

    pk = RSA.importKey(pk)
    cipher_rsa = PKCS1_OAEP.new(pk)

    session_key = cipher_rsa.decrypt(session_key)

    return session_key

def generate_session_key(other_person_public_key):
    
    session_key = get_random_bytes(16)
    # Encrypt the session key using the public key
    cipher_rsa = PKCS1_OAEP.new(other_person_public_key)
    
    encrypted_session_key = cipher_rsa.encrypt(session_key)

    return encrypted_session_key, session_key

def create_server():
    global server, public_key, recv_text, mylabel
    recv_text = ''
    while True:
        text = server.receive_text_from_client()
        txt = ''
        if text == "send_text":
            print(text)
            mode = server.client.recv(3).decode()

            if mode == 'ECB':
                txt = server.decryptECB(server.receive_encrypted_from_client())
            
            elif mode == 'CBC':
                iv = server.client.recv(16)
                encrypted = server.receive_encrypted_from_client()
                txt = server.decryptCBC(iv, encrypted)
                
            recv_text += f'{txt}\n'
            mylabel.config(text=recv_text) # update te messagebox
        
        elif text == "send_file":
            server.receive_file_from_client()

        elif text == "":
            return # text == '' when connection is lost
        
def check_address(text, window=None):
    global addr, port
    try:
        text.index(':')
    except ValueError:
        return
    else:
        text = text.split(':')
        if window is not None:
            window.destroy()
        addr, port = text[0], int(text[1])
        

def server_accept():
    global server, mylabel
    mylabel.config(text='accepting')
    server.server.listen()
    server.client, server.addr = server.server.accept()
    return

async def create_client():
    global client, connected, server, key_folder, session_key, mylabel, addr, port

    client = Client(addr, port) #adress and port given in the beggining of the program
                                #client tries to connect to server exposed on this ip:port
    server = Server('192.168.3.3', 9998)
    print("tworzenie serwera")
    thread1 = threading.Thread(target=server_accept, args=())
    thread1.start()
    while True:
        try:
            client.client.connect((addr, port))
        except ConnectionRefusedError:
            continue
        else:
            thread1.join()

            task = asyncio.create_task(server.receive_key())
            
            #with open(key_folder + '/public/public_key.pem', 'rb') as f:      #$uncomment and pass the file with
                #key = f.read()
            
            #client.send_key(key)
            public_key = await task 

            public_key = RSA.importKey(public_key)
            print(f'PUBLIC KEY: {public_key}')

            #task = asyncio.create_task(server.receive_key())

            ### TUTAJ NADAWCA
            session_key, before_cypher = generate_session_key(public_key)
            print(f'SESSION KEY: {session_key}')
            client.send_key(session_key)
            #print(session_key)
            #zapisac session key u klienta
            client.session_key = before_cypher
            server.session_key = before_cypher
            ### TUTAJ NADAWCA
            #sk = await task

            ### ODBIORCA
            #sk = decypher_session_key(sk)
            #client.session_key = sk
            #server.session_key = sk

            connected = True
            connection.config(text=f'Connected: {connected}')

            return
 
    

def connect():
    popup = tk.Tk()
    info = tk.Label(popup, text="Give another user address:", font="Raleway")
    info.grid(columnspan=3, column=1, row=0)
    text_input = tk.Text(popup,height = 1,width = 20)
    text_input.grid(columnspan=3,column=1, row=1)
    file_btn = tk.Button(popup, text='connect', command=lambda: check_address(text_input.get("1.0", "end-1c"), window=popup), font="Raleway", bg="#20bebe", fg="white", height=2, width=15)
    file_btn.grid(columnspan=3,column=1, row=2)
    popup.attributes('-topmost',True)
    popup.grab_set()
    popup.mainloop()

def client_handler():
    global addr, port, connected, mylabel
    connect()
    while True:
        asyncio.run(create_client())
        t1 = threading.Thread(target=create_server, args=(), daemon=True)
        t1.start()
        t1.join()


def main():
    global mylabel, client, server, connected, session_key, key_folder, connection, valid
    connected = False

    valid = False
    

    root = tk.Tk()
    canvas = tk.Canvas(root, width=500, height=300)
    root.withdraw()
    key_folder = check_if_keys_exist()
    password_handle(key_folder)

    root.deiconify()
    root.iconify()
    canvas.grid(columnspan=10, rowspan=10)
    #logo
    logo = Image.open('logo.png')
    logo = ImageTk.PhotoImage(logo)
    logo_label = tk.Label(image=logo)
    logo_label.image = logo
    logo_label.grid(column=1, row=0)
    #file transfer text
    instructions = tk.Label(root, text="Select file to transfer", font="Raleway")
    instructions.grid(columnspan=3, column=0, row=1)
    #message fransfer text
    instructions2 = tk.Label(root, text="write your message", font="Raleway")
    instructions2.grid(columnspan=3, column=0, row=3)
    text_input = tk.Text(root,height = 5,
                    width = 20)
    text_input.grid(columnspan=3,column=0, row=4)

    var = ''
    #ECB/CBC radiobuttons
    R1 = tk.Radiobutton(root, text="CBC", variable=var, value='CBC', command=lambda:client.set_cipher_mode('CBC'), width=4)
    R1.grid(column=1, row=5)

    R2 = tk.Radiobutton(root, text="ECB", variable=var, value='ECB', command=lambda:client.set_cipher_mode('ECB'), width=4)
    R2.grid(column=1, row=6)
    #file transfer button 
    file_btn = tk.Button(root, text='send file', command=lambda:open_file(), font="Raleway", bg="#20bebe", fg="white", height=2, width=15)
    file_btn.grid(column=1, row=2)
    #message tranfer button
    message_btn = tk.Button(root, text='send message', command=lambda:client.send_text(text_input.get("1.0", "end-1c")), font="Raleway", bg="#20bebe", fg="white", height=2, width=15)
    message_btn.grid(column=1,row=8)
    #field to show received text
    mylabel = tk.Label(root, text=f"messages:", font="Raleway")
    mylabel.grid(columnspan=3, column=0, row=9)

    #connection status
    connection = tk.Label(root, text=f"Connected: {connected}", font="Raleway")
    connection.grid(columnspan=3, column=0, row=10)

    canvas = tk.Canvas(root, width=600, height=250)
    canvas.grid(columnspan=3)    
    
    root.mainloop()


if __name__ == '__main__':
    main()
    
